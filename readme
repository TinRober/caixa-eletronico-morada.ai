# Caixa EletrÃ´nico API

API em **TypeScript** que simula o funcionamento de um caixa eletrÃ´nico.
Ela recebe um valor de saque e retorna a quantidade mÃ­nima de cÃ©dulas necessÃ¡rias para compor esse saque.

As cÃ©dulas disponÃ­veis sÃ£o: **100, 50, 20, 10, 5 e 2**.

---

## Tecnologias

* Node.js
* TypeScript
* Express 5
* ts-node-dev (desenvolvimento)
* HTTP JSON API

---

## Estrutura do projeto

```
src/
â”‚
â”œâ”€ app.ts            # ConfiguraÃ§Ã£o do Express e middlewares
â”œâ”€ server.ts         # InicializaÃ§Ã£o do servidor
â”‚
â”œâ”€ routes/
â”‚   â””â”€ saque.routes.ts   # Rotas da API
â”‚
â”œâ”€ controllers/
â”‚   â””â”€ saque.controller.ts  # LÃ³gica de recebimento e retorno das requisiÃ§Ãµes
â”‚
â”œâ”€ services/
â”‚   â””â”€ saque.service.ts     # Regras de negÃ³cio do saque
â””â”€ utils/
    â””â”€ http-error.ts         # Classe para erros HTTP personalizados
```

---


### ðŸ“Œ ConvenÃ§Ãµes de Nomenclatura

- **Pastas**: camelCase (`controllers`, `services`, `routes`, `utils`)  
- **Arquivos de cÃ³digo**: camelCase (`saqueController.ts`, `saqueService.ts`, `saqueRoutes.ts`, `httpError.ts`)  
- **Classes internas**: PascalCase (`SaqueController`, `SaqueService`, `HttpError`)  
- **MÃ©todos**: camelCase (`realizarSaque`, `calcularSaque`)  
- **Arquivos de configuraÃ§Ã£o**: camelCase (`app.ts` para configurar o Express, `server.ts` para iniciar o servidor)  

Essa organizaÃ§Ã£o garante:
- Facilidade para localizar arquivos e funcionalidades  
- ManutenÃ§Ã£o e escalabilidade mais simples  
- PadrÃ£o consistente para novos arquivos ou mÃ³dulos  

---

## Como rodar

1. Clonar o repositÃ³rio:
  
```bash
git clone <https://github.com/TinRober/caixa-eletronico-morada.ai>
cd caixa-eletronico
```

2. Instalar dependÃªncias:

```bash
npm install
```

3. Rodar em modo desenvolvimento (com recarga automÃ¡tica):

```bash
npm run dev
```

O servidor irÃ¡ iniciar em `http://localhost:5000/api`.

---

## Endpoints

### GET `/api`

Retorna uma mensagem de teste:

**Resposta:**

```json
"API de Saques funcionando!"
```

---

### POST `/api/saque`

Realiza um saque e retorna a quantidade de cÃ©dulas necessÃ¡rias.

**Body (JSON):**

```json
{
  "valor": 380
}
```

**Resposta (JSON):**

```json
{
 {
    "100": 3,
    "50": 1,
    "20": 1,
    "10": 1,
    "5": 0,
    "2": 0
  }
}
```

---

### Erros possÃ­veis

* Valor invÃ¡lido (nÃ£o inteiro ou <= 0):

```json
{
  "erro": "O valor deve ser um inteiro positivo."
}
```

* Valor impossÃ­vel de sacar com as cÃ©dulas disponÃ­veis (1 ou 3, por exemplo):

```json
{
  "erro": "NÃ£o Ã© possÃ­vel sacar esse valor com as cÃ©dulas disponÃ­veis."
}
```

* Erro interno no servidor:

```json
{
  "erro": "Erro interno no servidor."
}
```

---

## ObservaÃ§Ãµes

* A lÃ³gica do saque Ã© **gulosa**, utilizando sempre a cÃ©dula de maior valor possÃ­vel antes de partir para a prÃ³xima (exceto a nota de 5).
* Apenas os valores **1 e 3** nÃ£o podem ser sacados com as cÃ©dulas disponÃ­veis.
* O projeto utiliza **arquitetura limpa**, separando Controllers, Services e Utils.

---

## âš ï¸ Dificuldades Encontradas

### Antes de iniciar o projeto

1. **Aprender TypeScript**: Normalmente utilizo JavaScript, mas como a Morada.ai utiliza principalmente TypeScript, decidi me arriscar. Na prÃ¡tica, eu provavelmente usaria Python, que acredito deixaria a aplicaÃ§Ã£o mais simples.
2. **Definir a lÃ³gica do projeto**: Entender como criar a lÃ³gica do caixa eletrÃ´nico. Atualmente estou lendo *"Entendendo Algoritmos"*, e nele existe um capÃ­tulo sobre algoritmos gulosos. Descobri isso depois de jÃ¡ ter desenvolvido parte do projeto, mas pode ser Ãºtil adicionar insights futuramente.

### Durante o desenvolvimento

3. **Erro `TypeError: argument handler must be a function`**: O problema ocorreu porque eu tinha importado o mÃ©todo da classe, e nÃ£o a funÃ§Ã£o direta.
4. **Postman nÃ£o reconhecendo a URL**: Inicialmente estava usando a porta 3000, enquanto o projeto estÃ¡ configurado para 5000. AlÃ©m disso, quebras de linha no Postman estavam quebrando a URL.
5. **LÃ³gica gulosa para saque**: Ao testar com valores como 128, a lÃ³gica de sempre pegar a maior nota disponÃ­vel falhou, pois sobravam valores que nÃ£o podiam ser atendidos. Para contornar isso, a lÃ³gica foi ajustada para que, quando o restante fosse 1 ou 3, a nota de 5 nÃ£o fosse utilizada:

   ```ts
   // regra especial para a nota de 5
   if (nota === 5 && (restante === 1 || restante === 3)) {
     continue;
   }
   ```

   Essa regra sozinha nÃ£o resolveu completamente, mas o GitHub Copilot ajudou a chegar na soluÃ§Ã£o final:

   ```ts
   // regra final para a nota de 5
   if (nota === 5 && restante % 2 !== 1) {
     continue;
   }
   ```
6. **Formato do JSON de saÃ­da**: A saÃ­da estava em uma Ãºnica linha, enquanto o padrÃ£o esperado mostrava cada nota em linha separada. AlÃ©m disso, os objetos JS ordenam chaves numÃ©ricas do menor para o maior. Optei por nÃ£o transformar as notas em strings ou usar soluÃ§Ãµes alternativas para manter o cÃ³digo simples e organizado. TambÃ©m removi a mensagem `"Saque realizado!"` do JSON, seguindo o padrÃ£o solicitado.
7. **OrganizaÃ§Ã£o do projeto**: Foi necessÃ¡rio entender como estruturar pastas, arquivos, classes e mÃ©todos em TypeScript para manter o projeto bem organizado e padronizado.

**ObservaÃ§Ã£o**: Tentei consultar o perfil de quem criou o desafio para espelhar alguma estrutura de projeto em TypeScript, mas nÃ£o foi muito elucidativo. TambÃ©m percebi que outros candidatos nÃ£o implementaram um tratamento especial para a nota de 5, o que tornou essa parte do desafio mais interessante.

---

## scripts disponÃ­veis

```bash
npm run dev     # Rodar em modo desenvolvimento
npm run build   # Compilar TypeScript para JavaScript
npm start       # Rodar versÃ£o compilada
```

---

## Autor

Roberto Alzir Galarani Chaves
